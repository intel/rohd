// Copyright (C) 2021-2025 Intel Corporation
// SPDX-License-Identifier: BSD-3-Clause
//
// synchronous_propogator.dart
// Ultra light-weight events for signal propogation
//
// 2021 August 3
// Author: Max Korbel <max.korbel@intel.com>
//

import 'dart:collection';

/// A controller for a [SynchronousEmitter] that allows for
/// adding of events of type [T] to be emitted.
class SynchronousPropagator<T> {
  /// The [SynchronousEmitter] which sends events added to this.
  final SynchronousEmitter<T> emitter = SynchronousEmitter<T>();

  /// When set to `true`, will throw an exception if an event
  /// added is reentrant.
  bool throwOnReentrance = false;

  /// Adds a new event [t] to be emitted from [emitter].
  void add(T t) {
    if (throwOnReentrance && emitter.isEmitting) {
      throw Exception('Disallowed reentrance occurred.');
    }
    emitter._propagate(t);
  }
}

/// A stream of events of type [T] that can be synchronously listened to.
class SynchronousEmitter<T> {
  /// Registers a new listener [f] to be notified with an event of
  /// type [T] as an argument whenever that event is to be emitted.
  ///
  /// Returns a [SynchronousSubscription] representing this listener which can
  /// be cancelled.
  SynchronousSubscription<T> listen(void Function(T args) f) {
    final subscription = SynchronousSubscription<T>(f);
    _subscriptions.add(subscription._entry);
    return subscription;
  }

  /// A collection of actions to perform for each event.
  final LinkedList<_SynchronousSubscriptionEntry<T>> _subscriptions =
      LinkedList<_SynchronousSubscriptionEntry<T>>();

  /// Returns `true` iff this is currently emitting.
  ///
  /// Useful for reentrance checking.
  bool get isEmitting => _isEmitting;
  bool _isEmitting = false;

  /// Sends out [t] to all listeners.
  void _propagate(T t) {
    _isEmitting = true;

    // don't use an iterator/foreach in case we concurrently modify
    var entry = _subscriptions.firstOrNull;
    while (entry != null) {
      final subscription = entry.subscription;
      assert(subscription.isActive,
          'Inactive subscriptions should have been removed.');

      subscription.func(t);

      entry = entry.next;
    }

    _isEmitting = false;
  }

  /// Tells this emitter to adopt all behavior of [other].
  ///
  /// Tells this emitter to perform all the actions of [other] each
  /// time this would propagate.  Also clears all actions from [other]
  /// so that it will not execute anything in the future.
  void adopt(SynchronousEmitter<T> other) {
    // can't use an iterator/foreach because we are concurrently modifying
    var otherEntry = other._subscriptions.firstOrNull;
    while (otherEntry != null) {
      assert(otherEntry.subscription.isActive,
          'Inactive subscriptions should have been removed.');

      final nextOtherEntry = otherEntry.next;
      otherEntry.unlink(); // remove from other
      _subscriptions.add(otherEntry);
      otherEntry = nextOtherEntry;
    }
  }
}

/// Represents a subscription generated by listening to a [SynchronousEmitter].
class SynchronousSubscription<T> {
  /// The [Function] to execute when this subscription is triggered by an event.
  final void Function(T args) func;

  /// If true, then this subscription is actively triggering [func] on the
  /// registered event.
  bool get isActive => !_cancelled;

  /// Keeps track of whether this subscription has been cancelled.
  bool _cancelled = false;

  /// The entry in the linked list of subscriptions for this subscription.
  late final _SynchronousSubscriptionEntry<T> _entry =
      _SynchronousSubscriptionEntry(this);

  /// Constructs a new subscription so that [func] executes on certain events.
  SynchronousSubscription(this.func);

  /// Cancels the subscription, so that [func] will no longer be called when
  /// the listened-to event occurs.
  ///
  /// Calling this will make [isActive] `false`.
  void cancel() {
    if (!_cancelled) {
      _entry.unlink();
    }
    _cancelled = true;
  }
}

/// An entry in the linked list of subscriptions for a [SynchronousEmitter].
final class _SynchronousSubscriptionEntry<T>
    extends LinkedListEntry<_SynchronousSubscriptionEntry<T>> {
  /// The subscription that this entry represents.
  final SynchronousSubscription<T> subscription;

  /// Constructs a new entry for the linked list of subscriptions.
  _SynchronousSubscriptionEntry(this.subscription);
}
