// Copyright (C) 2021-2025 Intel Corporation
// SPDX-License-Identifier: BSD-3-Clause
//
// synth_builder.dart
// Definition for something that builds synthesis of a module hierarchy
//
// 2021 August 26
// Author: Max Korbel <max.korbel@intel.com>

import 'package:collection/collection.dart';
import 'package:rohd/rohd.dart';
import 'package:rohd/src/utilities/sanitizer.dart';
import 'package:rohd/src/utilities/uniquifier.dart';

/// A generic class which can convert a module into a generated output using
/// a [Synthesizer].
class SynthBuilder {
  /// The top-level [Module] to be synthesized.
  @Deprecated('Use `tops` instead.')
  Module get top => tops.length != 1
      ? throw SynthException('There must be exactly one top to use this API.')
      : tops.first;

  /// The top-level [Module]s to be synthesized.
  final List<Module> tops;

  /// The [Synthesizer] to use for generating an output.
  final Synthesizer synthesizer;

  /// A [Map] from instances of [Module]s to the type that should represent them
  /// in the synthesized output.
  final Map<Module, String> _moduleToInstanceTypeMap = {};

  /// All the [SynthesisResult]s generated by this [SynthBuilder].
  final Set<SynthesisResult> _synthesisResults = {};

  /// Map from Module -> its produced SynthesisResult for fast lookup.
  final Map<Module, SynthesisResult> _synthesisResultByModule = {};

  /// All the [SynthesisResult]s generated by this [SynthBuilder].
  Set<SynthesisResult> get synthesisResults =>
      UnmodifiableSetView(_synthesisResults);

  /// [Uniquifier] for instance type names.
  final Uniquifier _instanceTypeUniquifier = Uniquifier();

  /// Constructs a [SynthBuilder] based on the [top] module and using
  /// [synthesizer] for generating outputs.
  SynthBuilder(Module top, Synthesizer synthesizer)
      : this.multi([top], synthesizer);

  /// Constructs a [SynthBuilder] based on the provided [tops] modules and using
  /// [synthesizer] for generating outputs.
  SynthBuilder.multi(List<Module> tops, this.synthesizer)
      : tops = List.unmodifiable(tops) {
    for (final top in tops) {
      if (!top.hasBuilt) {
        throw ModuleNotBuiltException(top);
      }
    }

    // Allow the synthesizer to prepare with knowledge of top module(s)
    synthesizer.prepare(this.tops);

    final modulesToParse = <Module>[...tops];
    for (var i = 0; i < modulesToParse.length; i++) {
      final moduleI = modulesToParse[i];
      if (!synthesizer.generatesDefinition(moduleI)) {
        continue;
      }
      modulesToParse.addAll(moduleI.subModules);
    }

    // go backwards to start from the bottom (...now we're here)
    // critical to go in this order for caching to work properly
    modulesToParse.reversed
        .where(synthesizer.generatesDefinition)
        .forEach(_getInstanceType);
  }

  /// Collects a [List] of [String]s representing file contents generated by the
  /// [synthesizer].
  @Deprecated('Use `getSynthFileContents()` instead.')
  List<String> getFileContents() => synthesisResults
      .map((synthesisResult) => synthesisResult.toFileContents())
      .toList(growable: false);

  /// Collects a [List] of [SynthFileContents]s representing file contents
  /// generated by the [synthesizer].
  List<SynthFileContents> getSynthFileContents() => synthesisResults
      .map((synthesisResult) => synthesisResult.toSynthFileContents())
      .flattened
      .toList(growable: false);

  /// Provides an instance type name for [module].
  ///
  /// If a name already exists for [module], it will return the same one. If
  /// another [Module] is equivalent (as determined by comparing the
  /// [SynthesisResult]s), they will both get the same name.
  String _getInstanceType(Module module) {
    if (!synthesizer.generatesDefinition(module)) {
      return '*NONE*';
    }

    if (_moduleToInstanceTypeMap.containsKey(module)) {
      return _moduleToInstanceTypeMap[module]!;
    }
    var newName = module.definitionName;

    // Provide a lookup closure so synthesizers can access already-produced
    // synthesis results for submodules.
    final newSynthesisResult = synthesizer.synthesize(
      module,
      _getInstanceType,
      lookupExistingResult: (m) => _synthesisResultByModule[m],
      existingResults: _synthesisResultByModule,
    );
    // Note: top attribute is set by SchematicSynthesisResultBuilder.build()
    // when invoked with `isTop=true` from the SchematicSynthesizer.
    final existing = _synthesisResults.lookup(newSynthesisResult);
    if (existing != null) {
      // a name for this module already exists; reuse mapping
      newName = _moduleToInstanceTypeMap[existing.module]!;
      // Map this module to the canonical existing result so future
      // lookups by module succeed.
      _synthesisResultByModule[module] = existing;
    } else {
      _synthesisResults.add(newSynthesisResult);
      _synthesisResultByModule[module] = newSynthesisResult;
      newName = _instanceTypeUniquifier.getUniqueName(
          initialName: newName, reserved: module.reserveDefinitionName);
    }

    assert(Sanitizer.isSanitary(newName),
        'Module definition names should be sanitary.');

    _moduleToInstanceTypeMap[module] = newName;

    // add any required supporting modules to be synthesized
    newSynthesisResult.supportingModules?.forEach(_getInstanceType);

    return newName;
  }
}
