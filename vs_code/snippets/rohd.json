{
	"ROHD: Create Module": {
		"prefix": ["mod", "module", "Mod", "Module"],
		"body": [
			"class $1 extends Module {",
			"\t$1(Logic ${2:a}) {",
			"\t// Add to Input Port",
			"\t$2 = addInput('$2', $2);",
			"\t}",
			"}"
		],
		"description": "ROHD: Create Module."
	},
	"ROHD: Create Sequential Logic": {
		"prefix": ["seq", "sequential", "Seq", "Sequential"],
		"body": [
			"Sequential(clk, [",
			"]);"
		],
		"description": "ROHD: Create Sequential Logic."
	},
	"ROHD: Combinational Logic": {
		"prefix": ["comb", "combinational", "Comb", "Combinational"],
		"body": [
			"Combinational([",
            "\t//Assignment Here",
            "\t// e.g a0 < a1",
            "]);"
		],
		"description": "Create ROHD Combinational Logic."
	},
    "ROHD: Simple assign <=": {
        "prefix": ["assign"],
        "body": [
            "${1:srcLogic} <= ${2:destLogic};"
        ],
        "description": "Assignment Operator <= which used outside of the Sequential or Combinational conditional operator."
    },
    "ROHD: Conditional Assign": {
        "prefix": ["assign"],
        "body": [
            "${1:srcLogic} < ${2:destLogic};"
        ],
        "description": "Assignment Operator < which used in Sequential and Combinational conditional Operator."
    },
	"ROHD: Create If conditional": {
        "prefix": ["If", "if"],
        "body": [
            "If.block([",
            "\tIff(${1:condition}, [",
            "\t\t// If conditional and the respective then",
            "\t]),",
            "\tElseIf(${2:condition}, [",
            "\t\t// ElseIf conditional assignment, remove if not using",
            "\t]),",
            "\tElse([",
            "\t\t// Else condition, remove if not using",
            "\t])",
            "])"
        ],
        "description": "Create conditional with if, elseif, and else."
    },
    "ROHD: Create Case conditional": {
        "prefix": ["case", "Case"],
        "body": [
            "Case(${1:condition}, [",
            "\tCaseItem(${2:value}, [",
            "\t\t// Conditional assignment here",
            "\t]),",
            "\tCaseItem(${3:value}, [",
            "\t\t// Conditional Assignment here",
            "\t]),",
            "\t], defaultItem: [",
            "\t\t// optional to give a default item",
            "\t],",
            "\t// you can change to unique or priority on type",
            "\tconditionalType: ConditionalType.none",
            "\t),"
        ],
        "description": "Create case conditional."
    },
    "ROHD: Create CaseZ conditional": {
        "prefix": ["case", "Case", "caseZ", "CaseZ"],
        "body": [
            "CaseZ(",
            "\t\t${1:condition},",
            "\t\t[",
            "\t\t\tCaseItem(${2:value}, [",
            "\t\t\t\t// Conditional assignment here",
            "\t\t]),",
            "\t\t\tCaseItem(${3:value}, [",
            "\t\t\t\t// Conditional Assignment here",
            "\t\t]),",
            "\t\t],",
            "\t\tdefaultItem: [",
            "\t\t\t\t// optional to give a default item",
            "\t\t],",
            "\t\t\t\t// you can change to unique or priority on type",
            "\t\t\tconditionalType: ConditionalType.none),"
        ],
        "description": "Create CaseZ conditional"
    },
    "ROHD: Generate Simulation snippet.": {
        "prefix": ["sim", "Simulator", "simulation"],
        "body": [
            "WaveDumper(${1:module}, outputPath: '${2:wavedumpername}.vcd');",
            "// What is the timestep yu want to register your action?",
            "Simulator.registerAction(${3:25}, () {",
            "\t// Your control here",
            "\t// eg. en.put(1);",
            "\t// eg. reset.put(0);",
            "});",
            "Simulator.setMaxSimTime(${4:100});",
            "await Simulator.run();"
        ],
        "description": "Add simulation snippet. Normally used in performing testing."
    },
    "ROHD: Counter example.": {
        "prefix": ["example", "rohd", "counter"],
        "body": [
            "// Import the ROHD package",
            "import 'package:rohd/rohd.dart';",
            "// Define a class Counter that extends ROHD's abstract Module class",
            "class Counter extends Module {",
            "\t// For convenience, map interesting outputs to ",
            "\t// short variable names for consumers of this module",
            "\tLogic get val => output('val');\n",
            "\t// This counter supports any width, determined at run-time",
            "\tfinal int width;",
            "\tCounter(Logic en, Logic reset, Logic clk, {this.width=8, String name='counter'}) ",
            "\t\t\t: super(name: name) {\n",
            "\t\t// Register inputs and outputs of the module in the constructor.",
            "\t\t// Module logic must consume registered inputs and output to registered outputs.",
            "\t\ten    = addInput('en', en);",
            "\t\treset = addInput('reset', reset);",
            "\t\tclk   = addInput('clk', clk);",
            "\t\tvar val = addOutput('val', width: width);\n",
            "\t\t// A local signal named 'nextVal'",
            "\t\tvar nextVal = Logic(name: 'nextVal', width: width);",
            "\t\t// Assignment statement of nextVal to be val+1 (<= is the assignment operator)",
            "\t\tnextVal <= val + 1;\n",
            "\t\t// `Sequential` is like SystemVerilog's always_ff, ",
            "\t\t// in this case trigger on the positive edge of clk",
            "\t\tSequential(clk, [",
            "\t\t\t// `If` is a conditional if statement, ",
            "\t\t\t// like `if` in SystemVerilog always blocks",
            "\t\t\tIf(reset, then:[",
            "\t\t\t\t// the '<' operator is a conditional assignment",
            "\t\t\t\tval < 0",
            "\t\t\t], orElse: [If(en, then: [",
            "\t\t\t\tval < nextVal",
            "\t\t\t])])",
            "\t\t]);",
            "\t}",
            "}"
        ],
        "description": "A counter example build using ROHD. Can be use as a reference or simple template to build a module. Visit https://intel.github.io/rohd-website/docs/sample-example/ for details."
    },
    "ROHD: Finite State Machine (FSM)": {
        "prefix": ["fsm", "FSM"],
        "body": [
            "// Change stateA, stateB and stateC to your respective state",
            "enum FSMState { ${1:stateA}, ${2:stateB}, ${3:stateC} }\n",
            "class SampleFSMModule extends Module {",
            "\tlate FiniteStateMachine<FSMState> _state;\n",
            "\t// Modified Logics inputs based on your needs",
            "\tSampleFSMModule(Logic clk, Logic reset, Logic a, Logic b)",
            "\t\t\t: super(name: 'fsm_module_name') {",
            "\t\tclk = addInput('clk', clk);",
            "\t\treset = addInput(reset.name, reset);",
            "\t\ta = addInput(a.name, a);\n",
            "\t\t// The output of the fsm, modified this based on your needs",
            "\t\tfinal c = addOutput('output_pin');\n",
            "\t\t// Below is the example of the state transition, ",
            "\t\t// modified according to your needs",
            "\t\tfinal states = [",
            "\t\t\t// In the state of ${1:stateA}",
            "\t\t\tState(FSMState.${1:stateA}, events: {",
            "\t\t\t\t// If signal b is present, go to state of ${2:stateB}",
            "\t\t\t\tb: FSMState.${2:stateB},",
            "\t\t\t}, actions: [",
            "\t\t\t\t// You can add your respective logic output here",
            "\t\t\t\t// For example, in this state, c is still 0",
            "\t\t\t\t// you can add more logic here",
            "\t\t\t\tc < 0,",
            "\t\t\t]),",
            "\t\t\t// In the state of ${2:stateB}",
            "\t\t\tState(FSMState.${2:stateB}, events: {",
            "\t\t\t\t// if signal a is present, go to state of ${3:stateC}",
            "\t\t\t\ta: FSMState.${3:stateC}",
            "\t\t\t}, actions: [",
            "\t\t\t\t// You can add your respective logic output here",
            "\t\t\t\t// For example, in this state, c is still 0",
            "\t\t\t\t// you can add more logic here",
            "\t\t\t\tc < 0,",
            "\t\t\t]),",
            "\t\t\t// In the state of ${3:stateC}",
            "\t\t\tState(FSMState.${3:stateC}, events: {",
            "\t\t\t\t// Go back to ${1:stateA}",
            "\t\t\t\tConst(1): FSMState.${1:stateA}",
            "\t\t\t}, actions: [",
            "\t\t\t\t// You can add your respective logic output here",
            "\t\t\t\t// For example, in this state, c is change to 1",
            "\t\t\t\t// you can add more logic here",
            "\t\t\t\tc < 1,",
            "\t\t\t]),",
            "\t\t];\n",
            "\t\t_state = FiniteStateMachine(clk, reset, FSMState.${1:stateA}, states);\n",
            "\t\t// generate state diagram",
            "\t\t_state.generateDiagram(outputPath: 'sample_fsm_diagram.md');",
            "\t}",
            "}"
        ],
        "description": "An abstraction of the FSM build in ROHD. The API doc for state can be found at https://intel.github.io/rohd/rohd/State-class.html."
    },
     "ROHD Testbench": {
        "prefix": ["vf", "tb", "testbench"],
        "body": [
            "import 'dart:async';",
            "import 'dart:collection';",
            "import 'package:logging/logging.dart';",
            "import 'package:rohd/rohd.dart';",
            "import 'package:rohd_vf/rohd_vf.dart';",
            "",
            "/// Main function entry point to execute this testbench.",
            "Future<void> main({Level loggerLevel = Level.FINER}) async {",
            "  // Set the logger level",
            "  Logger.root.level = loggerLevel;",
            "",
            "  // Create the testbench",
            "  final tb = TopTB();",
            "",
            "  // Build the DUT",
            "  await tb.dut.build();",
            "",
            "  // Attach a waveform dumper to the DUT",
            "  WaveDumper(tb.dut);",
            "",
            "  // Set a maximum simulation time so it doesn't run forever",
            "  Simulator.setMaxSimTime(300);",
            "",
            "  // Create and start the test!",
            "  final test = DUTTest(tb.intf);",
            "  await test.start();",
            "}",
            "",
            "class TopTB {",
            "  // TODO: Create an instance of the DUT (The Module you want to test)",
            "  late final ${1:dutModule} dut;",
            "",
            "  // TODO: Build an instance of the interface for the DUT",
            "  final ${2:dutInterface} intf = ${2:dutInterface}();",
            "",
            "  TopTB() {",
            "    // TODO(Optional): Initialized your pin here",
            "    // Example: intf.clk <= SimpleClockGenerator(10).clk;",
            "",
            "    // Create the DUT, passing it our interface",
            "    dut = ${1:dutModule}(intf);",
            "  }",
            "}",
            "// A Test is like a top-level testing entity that contains the top testbench",
            "// Env and kicks off Sequences. Only one Test should be running at a time. The",
            "// Test also contains a central Random object to be used for randomization in",
            "// a reproducible way.",
            "class DUTTest extends Test {",
            "  // Interface of DUT",
            "  final ${2:dutInterface} intf;",
            "",
            "  late final DUTEnv env;",
            "",
            "  late final DUTSequencer _dutSequencer;",
            "",
            "  DUTTest(this.intf, {String name = 'dutTest'}) : super(name) {",
            "    env = DUTEnv(intf, this);",
            "    _dutSequencer = env.agent.sequencer;",
            "  }",
            "",
            "  // TODO: Uncomment this if you think this is helpful.",
            "  // A \"time consuming\" method, similar to `task` in SystemVerilog, which",
            "  // waits for a given number of cycles before completing.",
            "  // Example:",
            "  // Future<void> waitNegedges(int numCycles) async {",
            "  //   for (var i = 0; i < numCycles; i++) {",
            "  //     await intf.clk.nextNegedge;",
            "  //   }",
            "  // }",
            "",
            "  @override",
            "  Future<void> run(Phase phase) async {",
            "    unawaited(super.run(phase));",
            "    final obj = phase.raiseObjection('dut_test');",
            "",
            "    logger.info('Running the test...');",
            "",
            "    // TODO: Register your test action with Simulator here, you can",
            "    // change the Simulation time.",
            "    // Simulator.registerAction(1, () {",
            "    //   Example: intf.reset.put(0);",
            "    // });",
            "",
            "    // TODO: Add sequenceItem to the sequencer for initialization",
            "    // Example: _dutSequencer.add(DUTSeqItem(false));",
            "",
            "    // TODO: Kick start the Sequencer with n number of DUTSequence repetition",
            "    // Example: await _dutSequencer.start(DUTSequence(5));",
            "",
            "    logger.info('Done adding stimulus to the sequencer');",
            "",
            "    obj.drop();",
            "  }",
            "}",
            "",
            "class DUTEnv extends Env {",
            "  // Interface of DUT",
            "  final ${2:dutInterface} intf;",
            "",
            "  /// The agent that communicates with the DUT.",
            "  late final DUTAgent agent;",
            "",
            "",
            "  DUTEnv(this.intf, Component parent, {String name = 'dutEnv'})",
            "      : super(name, parent) {",
            "    agent = DUTAgent(intf, this);",
            "  }",
            "",
            "  @override",
            "  Future<void> run(Phase phase) async {",
            "    unawaited(super.run(phase));",
            "",
            "    // TODO: You can add a listener to the output of the monitor for some logging",
            "    // Example:",
            "    // agent.valueMonitor.stream.listen((event) {",
            "    //   logger.finer('');",
            "    // });",
            "  }",
            "}",
            "",
            "/// An agent to bundle the sequencer, driver, and monitors for one DUT.",
            "class DUTAgent extends Agent {",
            "  final ${2:dutInterface} intf;",
            "  late final DUTSequencer sequencer;",
            "  late final DUTDriver driver;",
            "  late final DUTValueMonitor valueMonitor;",
            "",
            "  DUTAgent(this.intf, Component parent, {String name = 'dutAgent'})",
            "      : super(name, parent) {",
            "    sequencer = DUTSequencer(this);",
            "    driver = DUTDriver(intf, sequencer, this);",
            "    valueMonitor = DUTValueMonitor(intf, this);",
            "  }",
            "}",
            "",
            "/// A basic [Sequencer] for the DUT.",
            "class DUTSequencer extends Sequencer<DUTSeqItem> {",
            "  DUTSequencer(Component parent, {String name = 'dutSequencer'})",
            "      : super(name, parent);",
            "}",
            "",
            "// A driver responisble for converting SequenceItem into signal transitions",
            "// on a hardware interface.",
            "class DUTDriver extends Driver<DUTSeqItem> {",
            "  final ${2:dutInterface} intf;",
            "",
            "  final Queue<DUTSeqItem> _pendingItems = Queue<DUTSeqItem>();",
            "",
            "  Objection? _driverObjection;",
            "",
            "  DUTDriver(this.intf, DUTSequencer sequencer, Component parent,",
            "      {String name = 'dutDriver'})",
            "      : super(name, parent, sequencer: sequencer);",
            "",
            "  @override",
            "  Future<void> run(Phase phase) async {",
            "    unawaited(super.run(phase));",
            "",
            "    // Listen to new items coming from the sequencer, and add them to a queue",
            "    sequencer.stream.listen((newItem) {",
            "      _driverObjection ??= phase.raiseObjection('dut_driver')",
            "        ..dropped.then((value) => logger.fine('Driver objection dropped'));",
            "      _pendingItems.add(newItem);",
            "    });",
            "",
            "    // Every clock negative edge, drive the next pending item if it exists",
            "    intf.clk.negedge.listen((args) {",
            "      if (_pendingItems.isNotEmpty) {",
            "        final nextItem = _pendingItems.removeFirst();",
            "        drive(nextItem);",
            "        if (_pendingItems.isEmpty) {",
            "          _driverObjection?.drop();",
            "          _driverObjection = null;",
            "        }",
            "      }",
            "    });",
            "  }",
            "",
            "  // Translate a SequenceItem into pin wiggles",
            "  // TODO: Map sequence item to respective pin",
            "  void drive(DUTSeqItem? item) {",
            "    // Example:",
            "    // if (item == null) {",
            "    //   intf.en.inject(0);",
            "    // } else {",
            "    //   intf.en.inject(item.en);",
            "    // }",
            "  }",
            "}",
            "",
            "/// A monitor is responsible for watching an interface and reporting out",
            "/// interesting events onto an output stream.",
            "class DUTValueMonitor extends Monitor<LogicValue> {",
            "  final ${2:dutInterface} intf;",
            "",
            "  DUTValueMonitor(this.intf, Component parent,",
            "      {String name = 'dutValueMonitor'})",
            "      : super(name, parent);",
            "",
            "  @override",
            "  Future<void> run(Phase phase) async {",
            "    unawaited(super.run(phase));",
            "    await intf.reset.nextNegedge;",
            "",
            "    intf.clk.posedge.listen((event) {",
            "",
            "      // TODO: Add the output pin that you want to monitor here",
            "      // Example: add(intf.val.value);",
            "    });",
            "  }",
            "}",
            "",
            "",
            "// A Sequence is a modular object which has instructions for how to send",
            "// SequenceItems to a Sequencer. A typical use case would be sending a",
            "// collection of SequenceItems in a specific order.",
            "class DUTSequence extends Sequence {",
            "  final int numRepeat;",
            "",
            "  DUTSequence(this.numRepeat, {String name = 'dutSequence'}) : super(name);",
            "",
            "  @override",
            "  Future<void> body(Sequencer sequencer) async {",
            "    final dutSequencer = sequencer as DUTSequencer;",
            "    for (var i = 0; i < numRepeat; i++) {",
            "      // TODO: Add sequenceItem to the Sequence that we want to send to test",
            "      // Example: dutSequencer",
            "      //   ..add(DUTSeqItem(true))",
            "      //   ..add(DUTSeqItem(false));",
            "    }",
            "  }",
            "}",
            "",
            "// A SequenceItem represents a collection of information to transmit across",
            "// an interface. A typical use case would be an object representing",
            "// a transaction to be driven over a standardized hardware interface.",
            "class DUTSeqItem extends SequenceItem {",
            "  // TODO: Add your sequence Item",
            "  // Example: final bool _enable;",
            "",
            "  // TODO: Register your input variable to the constructor",
            "  // Example: DUTSeqItem(this._enable);",
            "",
            "  // TODO: Create a getter for monitoring purposes",
            "  // int get en => _enable ? 1 : 0;",
            "}",
            ""
        ],
        "description": "Dart Testbench Template"
    }
}